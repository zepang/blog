---
title: 一些关于Git的内容
date: '2018-01-10'
---

# toc

# 响应式和自适应布局

能够在不同的尺寸的屏幕下响应式的展示内容称之为响应式的布局，通常，屏幕尺寸之间相差较大。

在同一类或者屏幕想差不多的设备中进行布局适配称之为自适应布局。比如不同的手机之间。

另外需要提醒的是，在对页面要求比较高的情况下，建议单独适配移动端的布局。

# 物理像素和设备独立像素

物理像素通常又称为设备像素，是显示设备中一个最微小的物理部件。一个设备的物理像素是不变的，每个像素都可以通过操作系统设置显示的亮度颜色。

所谓的一倍屏，二倍屏，三倍屏就是指使用多少的物理像素来显示一个css的像素。拿一张图来具体说明：

![](./retina-web.jpg)

**也就是说，在普通屏幕下，1个css像素对应着1个物理像素；在Retina屏幕下，一个css像素对应的却是4个像素**

设备独立像素通常又称为与设备无关像素，比如css像素。同样大小的css像素表示的内容，在普通屏幕和Retina屏幕占据的空间是一样的。

# 设备像素比

设备像素比（device pixel ratio），简称dpr，即物理像素和设备独立像素的比值。

在web浏览器中，我们可以通过 `window.devicePixelRatio` 来获取 dpr。

此外，我们通常会在css的媒体查询中使用到dpr，来区分多倍屏设备

```css
@media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2){ }
```

# 布局视口，视觉视口，理想视口

**布局视口：**就是指浏览器中用来显示网页的区域。

在pc端，布局视口的大小就是指浏览器的窗口大小。

在移动端，浏览器为了防止pc端网页在移动端显示拥挤，会给布局视口设置一个特定的宽度，大部分的为980px。

有的人会说不对呀，我手机端看到的网页宽度就是和屏幕宽度的大小是一致的，那是因为现在大部分移动端的网页，都使用的是理想视口。

我们可以通过document.documentElement.clientWidth / clientHeight来获取布局视口大小。

**视觉视口：**用户正在看到的网页的区域。

用户可以通过缩放来查看网站的内容。

如果用户缩小网站，我们看到的网站区域将变大，此时视觉视口也变大了，同理，用户放大网站，我们能看到的网站区域将缩小，此时视觉视口也变小了。

但是无论用户如何缩放，都不会改变布局视口的大小。

我们可以通过window.innerWidth / innerHeight来获取视觉视口大小。

**理想视口：**当布局视口大小等于视觉视口的时候，即为理想视口。

可以添加下边的代码来达到理想视口的效果：

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

我们可以通过screen.width / height来获取理想视口大小。

需要注意，通过设置viewport，会影响到css媒体查询。

了解以上几个概念就差不多了，接下来进入主题，讲讲开发中需要了解的内容。

# 设计稿的像素转换

通常，考虑到Retina屏幕能够显示的物理像素，设计师在设计时，会基于iphone6给出750px或者1125px的设计稿，这种设计稿分别叫二倍图和三倍图。

在进行页面布局的时候，我们需要将物理像素转换成设备独立像素。

以750px设计稿为例，设计稿中一个元素的高度为200px。

在理想视口的情况下，iphone6的视口大小为375px。

要想保证这个元素在375px的视口中正确的展示，我们就需要保证它的屏占比，则我们给定的css像素应为200px/2=100px。

以1125px设计稿为例就得除以3。

在以上的前提下，如果要适配其他屏幕大小和iphone6不同的机型，如何保证内容屏占比？

# 基于rem的flexible

为了解决移动端不同屏幕（大小）的机型的布局问题。

所以在很早之前淘宝就出来了基于rem的布局解决方案flexible.js。

我们看下flexible.js的原理：

```js
// set 1rem = viewWidth / 10
  function setRemUnit () {
    var rem = docEl.clientWidth / 10
    docEl.style.fontSize = rem + 'px'
  }

  setRemUnit()
```

通过js计算跟节点的字号大小，然后用rem作为单位。

还是以750px设计稿为例，假设Y为设计稿某个元素的尺寸，y为屏幕中的css尺寸，为保持元素在设计稿和屏幕的占比，则满足Y/750 = y/10*rem。

所以计算得 y = (Y * 10 * rem)/750 (单位px) = Y/75 (单位rem)，有的时候为了方便计算，会将这个10换成75，也就是屏幕75等分。

之后随着viewport单位在浏览器中逐渐兼容，所以flexible这种rem的方案逐渐被废弃，这种方案实际上就是viewport单位的替代品。

# viewport单位

vh、vw方案即将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。

* vw(Viewport's width)：1vw等于视觉视口的1%

* vh(Viewport's height) :1vh 为视觉视口高度的1%

* vmin : vw 和 vh 中的较小值

* vmax : 选取 vw 和 vh 中的较大值

如果视觉视口为375px，那么1vw = 3.75px，这时UI给定一个元素的宽为75px（设备独立像素），我们只需要将它设置为75 / 3.75 = 20vw。

这里的比例关系我们也不用自己换算，我们可以使用PostCSS的 postcss-px-to-viewport 插件帮我们完成这个过程。写代码时，我们只需要根据UI给的设计图写px单位即可。

当然，没有一种方案是十全十美的，vw同样有一定的缺陷：

* px转换成vw不一定能完全整除，因此有一定的像素差。

* 比如当容器使用vw，margin采用px时，很容易造成整体宽度超过100vw，从而影响布局效果。

当然我们也是可以避免的，例如使用padding代替margin，并且配合box-sizing，碰到vw和px混合使用的时候，结合calc()函数一起使用，这样就可以完美的解决。