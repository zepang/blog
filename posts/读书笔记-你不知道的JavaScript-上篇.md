---
title: 你不知道的JavaScript系列摘录-上卷
img: 'https://placem.at/places?h=140'
date: '2019-04-29'
---
## 第一章 作用域是什么？

# toc

存储和查找变量的规则。

### 1.1 编译原理：
* JavaScript实际上一门编译语言。任何JavaScript的代码在执行前都要进行编译。大部分的编译发生在代码执行前的几微妙（甚至更短）。
* 编译的三个过程：
  * 分词/词法分析
  * 解析/语法分析
  * 代码生成

### 1.2 作用域的理解
* 对 JavaScript 代码进行处理时需要参与的三个成员 引擎，编译器，作用域以及它们分别的作用。
* 作用域参与编译器和引擎的工作，协助编译器和引擎存储和查找变量

### 1.3 作用域嵌套
* 遍历嵌套作用域链的规则：引擎从当前的执行作用域开始查找变量，如果找不到，
就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都
会停止。

### 1.4 异常
在普通模式下，执行 LHS 查询，如果直到顶层作用域都无法找到所需的变量，会在顶层作用域，隐式的创建一个。执行 RHS 查询，在所有的嵌套作用中，无法找到需要的变量，引擎会抛出 ReferenceError 异常。
在严格模式下（'use strict'），执行 LHS 查询，如果直到顶层作用域都无法找到所需的变量，不会在顶层作用域隐式的创建一个，引擎会抛出 ReferenceError 异常，因为严格模式不允许隐式创建变量。

---

## 第二章 词法作用域
作用域共有两种主要的工作模型，第一种最为普遍，被大多数编程语言所采用的词法作用域。另外一种叫做动态作用域，仍有一些编程语言在使用。JavaScript所采用的模型是词法作用域。
举个例子说明动态作用域和词法作用域的区别：
~~~js
function foo () {
  console.log(a)
}
function bar () {
  var a = 3
  foo()
}
var a = 2
bar() // 2
~~~
上边的代码 js 会输出 2，因为 foo 函数的 RHS 查找变量是通过全局的作用域进行查找的
如果 js 是动态语言，那么结果就会输出 3，动态作用域不关心函数是在何处声明的，只关心在何处调用。
### 2.1 词法阶段
在之前的[1.1编译原理](###1.1编译原理)中提到编译器工作的三个阶段，第一个是词法分析，大部分标准编译器的第一个工作阶段叫做词法化。
**简单的来说，词法作用域就是定义在词法阶段的作用域。换句话来说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，由此，当词法分析器处理代码时，会保持作用域不变**
### 2.2 词法欺骗
刚才所说，词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（欺骗），词法作用域？

JavaScript 中有两种方式：eval 和 with

#### 2.2.1 eval
eval 函数可以接收一个字符串为参数，并且将其中内容作为好像在书写时就在当前位置的代码来执行。请看下面例子：
~~~js
function foo (str) {
  eval(str)
  console.log(a)
}
var a = 1
foo("var a = 3") // 3
~~~
eval 常用来动态创建代码，但是，在严格模式中，eval(...) 在运行时有其自己的作用域，意味着无法修改所在地作用域。
~~~js
function foo (str) {
  eval(str)
  console.log(a) // ReferenceError: a is not defined
}
foo("var a = 3") 
~~~
setTimeout(...) 和 setInterval(...) 的第一个参数可以是字符串，字符串的代码可以解释成正确的代码执行。这些功能已经过时，不要使用它。

new Function(...) 函数最后一个参数可以接收代码字符串，并且将其转化成动态代码。这种做法比eval(...)略微安全，但是，也要尽量避免使用。

#### with
通常被当作重复引用同一个对象的多个属性的快捷方式，可以不需要重复引用对象本身。
~~~js
var obj = {
  a: 1,
  b: 2,
  c: 3
}
obj.a = 4
obj.b = 5
obj.c = 6

with(obj) {
  a = 4
  b = 5
  c = 6
  d = 7
}

console.log(d) // 7
~~~
with 可以将一个没有或者多个属性的对象处理为一个完全隔离的词法作用域。实际上，是根据你传递给它的对象凭空创造一个新的词法作用域。比如，你传递 obj 给 with，实际上，with 以 obj 作为当前作用域，在 obj 中没有找到 d ，所以，在上层作用域中找，也没有，那么就创建了 d 变量。

---

## 第三章 函数作用域和块作用域
JavaScript是如何形成作用域气泡？

两种方式，一种是函数作用域，另一种是块作用域。

### 函数作用域
每次创建一个函数就可以为其自身创建一个作用域气泡。
### 块作用域
通过 with try/catch let const 等关键字形成的块级作用域。
其中try/catch 中的 catch 分句会创建块作用域，其中声明的变量只能在catch内部有效。

----

## 第四章 提升
先看下面代码：
```js
a = 2
var a

console.log(a) // 2
console.log(a) // undefined

var a = 2
```
通常我们理解的JavaScript的代码是一行一行从上往下执行，所以我们猜测上边代码会报 ReferenceError 错误。但是，由于 JavaScript 是先编译后执行，在编译阶段会收集所有的声明，虽然，我们看到的 a 声明代码在 赋值代码后面，但是，编译器已经提前在作用域中声明了 a，所以，在执行阶段，对 a 进行 RHS 查询，不会报错。这一个现象叫提升。

JavaScript 中除了上边的变量提升，还存在函数提升，不过只针对 function 关键字声明的函数。

---- 

## 第五章 作用域闭包
### 闭包
闭包的产生？

当函数记住并且访问词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

什么叫闭包？

~~~js
function foo () {
  var a = 2
  function bar () {
    console.log(a)
  }
  bar()
}
f00()
~~~
我们可以这么解释上边的代码，bar 函数在创建时是在 foo 函数内部，所以，bar 函数所适应访问的变量的规则时，当前作用域 -> foo作用域 -> foo外层作用域，bar 函数在执行的时候，根据作用域嵌套规则，首先会在当前作用域寻找 a，不存在就会往上寻找，而 foo 作用域 是可以访问到 a 的。
那么下边代码我们该如何解释？
~~~js
function foo () {
  var a = 2
  function bar () {
    console.log(a)
  }
  return bar
}
var baz = foo()
baz() // 2 闭包产生的效果
~~~
如果我们继续按照上边的思路去解释，那么我们会发现一个问题，由于JavaScript本身存在的垃圾回收机制，在 var baz = foo() 执行完后，foo 函数就应该会回收，所以 foo 中声明的所有上下文环境变量就该销毁，显然baz()执行的时候是无法找到 a 的。那么此处最终结果依然输出 2，可以看出 foo 在执行时生成的上下文环境变量没有被销毁，闭包阻止了垃圾回收。

个人的理解：
- 作用域
  * 同意书上JavaScript使用的是词法作用域，所以决定变量的使用范围是在词法分析阶段。
  * JavaScript作用域从范围来分，分为全局作用域和局部作用域，从不同的生成方式来分，分为函数作用域（由创建函数形成的作用域）和块级作用域（形成块级作用域的关键字声明形成）。
- 闭包

  当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时
  就产生了闭包。
  * 在函数A中返回函数B，函数B对函数A的作用域存在引用，我们就说函数A形成了闭包，函数B就是函数A的闭包。

---

# 第二部分

## 第一章 关于 this

### 对 this 的误解

* this 指向函数自身
~~~js
function foo(num) {
  console.log( "foo: " + num );
// 记录 foo 被调用的次数
  this.count++;
}
foo.count = 0;
var i;
for (i=0; i<10; i++) {
  if (i > 5) {
  foo( i );
  }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9
// foo 被调用了多少次？
console.log( foo.count ); // 0 -- WTF?
~~~
foo 调用实际上是增加了全局的 count。

**就针对上面的代码，如何回避以上问题：** 
* 第一种
~~~js
function foo(num) {
  console.log( "foo: " + num );
  // 记录 foo 被调用的次数
  data.count++;
}
var data = {
  count: 0
};
var i;
for (i=0; i<10; i++) {
  if (i > 5) {
  foo( i );
  }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9
// foo 被调用了多少次？
console.log( data.count ); // 4
~~~
创建一个对象来存储 count，回避掉 this 的问题，用词法作用域来解释。
* 第二种
~~~js
function foo(num) {
  console.log( "foo: " + num );
  // 记录 foo 被调用的次数
  foo.count++;
}
var data = {
  count: 0
};
var i;
for (i=0; i<10; i++) {
  if (i > 5) {
  foo( i );
  }
}
~~~
使用具名函数，指定函数名。
* 第三种
~~~js
function foo(num) {
  console.log( "foo: " + num );
  // 记录 foo 被调用的次数
  // 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo
  this.count++;
}
foo.count = 0;
var i;
for (i=0; i<10; i++) {
  if (i > 5) {
  // 使用 call(..) 可以确保 this 指向函数对象 foo 本身
    foo.call( foo, i );
  }
}
// foo: 6
// foo: 7
// foo: 8
// foo: 9
// foo 被调用了多少次？
console.log( foo.count ); // 4
~~~
使用 call apply bind 这一类，强制绑顶 this 的指向。

* this 指向函数作用域
（说实话没看懂作者举的例子和当前的主题有啥干系）

#### 小结 

this 既不指向函数自身也不指向函数的词法作用域，this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。

---

## 第二章 全面了解 this 
### this的绑定规则
#### 默认绑定

独立函数调用（作为普通的函数调用），在非严格的模式下，this 指向全局对象。在严格模式下，this 是 undefined。
~~~js
function foo () {
  console.log(this.a)
}
var a = 2
foo()
~~~
书上的说法是 foo 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定。

